/**
 * Git commit management
 */

import simpleGit, { SimpleGit } from 'simple-git';
import * as path from 'path';
import { logger } from '../utils/logger';

export class CommitManager {
  private git: SimpleGit;
  private repoPath: string;

  constructor(repoPath: string) {
    this.repoPath = repoPath;
    this.git = simpleGit(repoPath);
  }

  /**
   * Stage and commit generated files
   */
  async commitFiles(
    files: string[],
    message?: string
  ): Promise<{ hash: string; message: string }> {
    try {
      // Convert absolute paths to relative paths
      const relativePaths = files.map(f => path.relative(this.repoPath, f));

      // Stage files
      await this.git.add(relativePaths);
      logger.info(`Staged ${relativePaths.length} files`);

      // Create commit message
      const commitMessage =
        message ||
        this.generateCommitMessage(relativePaths);

      // Commit
      const result = await this.git.commit(commitMessage);
      logger.success(`Created commit: ${result.commit.substring(0, 7)}`);

      return {
        hash: result.commit,
        message: commitMessage,
      };
    } catch (error) {
      logger.error('Failed to commit files', error as Error);
      throw error;
    }
  }

  /**
   * Generate a descriptive commit message
   */
  private generateCommitMessage(files: string[]): string {
    const fileTypes = this.categorizeFiles(files);

    const parts: string[] = ['ðŸ“š Add lean-intel analysis', ''];

    if (fileTypes.docs > 0) {
      parts.push(`- ${fileTypes.docs} documentation file${fileTypes.docs > 1 ? 's' : ''}`);
    }

    if (fileTypes.analysis > 0) {
      parts.push(`- ${fileTypes.analysis} analysis report${fileTypes.analysis > 1 ? 's' : ''}`);
    }

    parts.push('', 'Generated by lean-intel');
    parts.push('https://github.com/leandigital/lean-intel');

    return parts.join('\n');
  }

  /**
   * Categorize files by type
   */
  private categorizeFiles(files: string[]): { docs: number; analysis: number } {
    let docs = 0;
    let analysis = 0;

    files.forEach(file => {
      const filename = path.basename(file).toUpperCase();

      if (
        filename.includes('SECURITY') ||
        filename.includes('LICENSE') ||
        filename.includes('QUALITY') ||
        filename.includes('COST') ||
        filename.includes('HIPAA')
      ) {
        analysis++;
      } else {
        docs++;
      }
    });

    return { docs, analysis };
  }

  /**
   * Check if there are uncommitted changes
   */
  async hasUncommittedChanges(): Promise<boolean> {
    const status = await this.git.status();
    return !status.isClean();
  }

  /**
   * Get the last commit hash
   */
  async getLastCommitHash(): Promise<string> {
    const log = await this.git.log({ maxCount: 1 });
    return log.latest?.hash || '';
  }

  /**
   * Push commits to remote
   */
  async push(branchName: string, remote = 'origin'): Promise<void> {
    try {
      await this.git.push(remote, branchName, ['--set-upstream']);
      logger.success(`Pushed to ${remote}/${branchName}`);
    } catch (error) {
      logger.error('Failed to push commits', error as Error);
      throw error;
    }
  }
}
