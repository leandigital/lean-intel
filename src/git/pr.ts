/**
 * Pull Request management for GitHub
 */

import { Octokit } from '@octokit/rest';
import simpleGit, { SimpleGit } from 'simple-git';
import { PROptions, GitHubPRResponse, AnalysisResults } from '../types';
import { logger } from '../utils/logger';
import { formatCost, formatDuration } from '../utils/costEstimator';

export class PRManager {
  private octokit: Octokit;
  private git: SimpleGit;

  constructor(repoPath: string, githubToken: string) {
    this.git = simpleGit(repoPath);
    this.octokit = new Octokit({ auth: githubToken });
  }

  /**
   * Create a pull request on GitHub
   */
  async createPR(
    branchName: string,
    baseBranch: string,
    results: AnalysisResults
  ): Promise<GitHubPRResponse> {
    try {
      // Get repository information
      const repoInfo = await this.getRepoInfo();

      if (!repoInfo) {
        throw new Error('Could not determine GitHub repository. Is this a GitHub repository?');
      }

      const { owner, repo } = repoInfo;

      // Generate PR title and description
      const prOptions = this.generatePRContent(branchName, baseBranch, results);

      // Create the PR
      logger.info('Creating pull request on GitHub...');

      const response = await this.octokit.pulls.create({
        owner,
        repo,
        title: prOptions.title,
        head: branchName,
        base: baseBranch,
        body: prOptions.description,
      });

      // Add labels if specified
      if (prOptions.labels && prOptions.labels.length > 0) {
        await this.octokit.issues.addLabels({
          owner,
          repo,
          issue_number: response.data.number,
          labels: prOptions.labels,
        });
      }

      logger.success(`Pull request created: ${response.data.html_url}`);

      return {
        url: response.data.html_url,
        number: response.data.number,
      };
    } catch (error) {
      logger.error('Failed to create pull request', error as Error);
      throw error;
    }
  }

  /**
   * Extract repository owner and name from git remote
   */
  private async getRepoInfo(): Promise<{ owner: string; repo: string } | null> {
    try {
      const remotes = await this.git.getRemotes(true);

      // Look for origin remote
      const origin = remotes.find(r => r.name === 'origin');
      if (!origin) {
        return null;
      }

      // Parse GitHub URL
      // Supports both HTTPS and SSH formats:
      // - https://github.com/owner/repo.git
      // - git@github.com:owner/repo.git
      const url = origin.refs.fetch;

      const match = url.match(/github\.com[:/](.+?)\/(.+?)(\.git)?$/);
      if (!match) {
        return null;
      }

      return {
        owner: match[1],
        repo: match[2],
      };
    } catch (_error) {
      logger.debug('Could not parse repository info');
      return null;
    }
  }

  /**
   * Generate PR title and description
   */
  private generatePRContent(
    branchName: string,
    _baseBranch: string,
    results: AnalysisResults
  ): PROptions {
    const { analyzers, totalCost, totalDuration, generatedFiles } = results;

    const successfulAnalyzers = analyzers.filter(a => a.status === 'success');
    const failedAnalyzers = analyzers.filter(a => a.status === 'error');

    // Categorize files
    const docsFiles = generatedFiles.filter(f =>
      ['ARCHITECTURE', 'CLAUDE', 'COMPONENTS', 'ROUTING'].some(doc =>
        f.toUpperCase().includes(doc)
      )
    );

    const analysisFiles = generatedFiles.filter(f =>
      ['SECURITY', 'LICENSE', 'QUALITY', 'COST', 'HIPAA'].some(doc =>
        f.toUpperCase().includes(doc)
      )
    );

    // Build description
    const description = `## ðŸ“š Automated Documentation & Analysis

Generated by [lean-intel](https://github.com/leandigital/lean-intel)

### ðŸ“Š What's Included

**Documentation:**
${docsFiles.length > 0 ? docsFiles.map(f => `- \`${f}\``).join('\n') : '- No documentation generated'}

**Analysis Reports:**
${analysisFiles.length > 0 ? analysisFiles.map(f => `- \`${f}\``).join('\n') : '- No analysis reports generated'}

### âœ… Analyzers Run

${successfulAnalyzers.map(a => `- âœ“ **${a.name}** (${formatCost(a.cost)}, ${a.duration.toFixed(0)}s)`).join('\n')}

${failedAnalyzers.length > 0 ? `\n### âŒ Failed Analyzers\n\n${failedAnalyzers.map(a => `- âœ— **${a.name}** - ${a.error}`).join('\n')}` : ''}

### ðŸ’° Cost & Duration

- **Total Cost:** ${formatCost(totalCost)}
- **Total Duration:** ${formatDuration(totalDuration)}
- **Generated Files:** ${generatedFiles.length}

### ðŸ¤– About This PR

This PR was automatically generated by lean-intel, an AI-powered documentation and code analysis tool.

All content is generated by lean-intel and verified against your actual codebase. Review carefully before merging.

**Project Type:** ${results.projectContext.projectType}
**Frameworks:** ${results.projectContext.frameworks.join(', ') || 'None detected'}
**Languages:** ${results.projectContext.languages.join(', ') || 'None detected'}

---

**Feedback?** Open an issue at [lean-intel](https://github.com/leandigital/lean-intel/issues)
`;

    return {
      branch: branchName,
      title: `ðŸ“š Add lean-intel documentation and analysis`,
      description,
      labels: ['documentation', 'automated', 'lean-intel'],
    };
  }

  /**
   * Check if GitHub token has required permissions
   */
  async validateToken(): Promise<boolean> {
    try {
      const { data } = await this.octokit.users.getAuthenticated();
      logger.debug(`Authenticated as ${data.login}`);
      return true;
    } catch (error) {
      logger.error('GitHub token validation failed', error as Error);
      return false;
    }
  }
}
